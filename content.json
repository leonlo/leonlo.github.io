[{"title":"办公室神游记","date":"2017-01-06T04:00:54.000Z","path":"2017/01/06/办公室神游记/","text":"2017-06-07 13:52不再犹豫 2017-05-16 09:57像玻璃杯，一碰就会碎。 2017-05-16 10:15生活原本是无趣的，工作原本是枯燥的。但你真的不能让原本只是原本…… 2017-05-08 17:07再这样被委以“重任”，我真的要成全干工程师了啊。（苦笑） 2017-04-19 10:01入职新公司半年了，真的快成全干工程师了。 2017-03-29 10:05找自己 2017-01-25 11:30知乎问题：喜欢上了洗浴中心技师，我是不是很low？如果想要进一步，我该怎么做？ 虽然没有过这样的经历，但是我竟然有些感动，我是不是三观不正啊…… 2017-01-06 12:00是在意赐予了折磨的权利 2016-03-28 17:01「情怀」太私人化，自己的也许在他人眼里一文不值。不过那又怎样？ 2016-03-24 14:23「做想做的事」境界太高，我还是去追求「不做不想做的事」吧。 2016-03-21 18:02 Time You Enjoy Wasting is Not Wasted Time.","tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"http://yoursite.com/tags/乱七八糟/"}]},{"title":"在macOS下使用VSCode搭建Go开发环境","date":"2016-09-27T15:35:39.000Z","path":"2016/09/27/在macOS下使用VSCode搭建Go开发环境/","text":"准备 安装Go，可以在golang.org下载（下载最新的），在Terminal中键入go可以看到所有支持的commond，这意味着你的Go已经装好了 注意事项：Go安装完毕后一定要配置好GOPATH这个环境变量，不然你的VSCode将无法成功部署。 去微软的VSCode官网下载VSCode并安装 vscode-go插件及常用扩展依赖工具 安装vscode-go 在VSCode中cmd+shift+P，输入框中输入ext install，回车，在「扩展」面板输入框中输入Go，待服务器返回最新的地址后，点击安装，然后重启，此时你的vscode-go已经安装完毕。 常用工具 vscode-go 插件需要一些额外的工具，安装它们你只需要复制到Terminal中执行即可，它们会安装到你的GOPATH目录下。 123456789101112131415161718#gocode: go get -u -v github.com/nsf/gocode#godef: go get -u -v github.com/rogpeppe/godef#golint: go get -u -v github.com/golang/lint/golint#go-outline: go get -u -v github.com/lukehoban/go-outline#goreturns: go get -u -v sourcegraph.com/sqs/goreturns#gorename: go get -u -v golang.org/x/tools/cmd/gorename#gopkgs: go get -u -v github.com/tpng/gopkgs#go-symbols: go get -u -v github.com/newhook/go-symbols#guru: go get -u -v golang.org/x/tools/cmd/guru 注：一条一条执行很累人的，你可以简单写进一个脚本，执行脚本。网络条件良好的情况下，去抽根烟回来就好了。 使VSCode支持Go语言调试 安装调试工具delve，打开Termina输入如下命令。 12#delve项目中安装文档表示如果你安装了homebrew可以通过 \"brew install go-delve/delve/delve\" 来安装（我失败了）。go get -v -u github.com/peterh/liner github.com/derekparker/delve/cmd/dlv 由于调试工具没有代码签名，此时在Mac下是无法正常使用VSCode调试Go程序的，可以通过如下几个步骤解决问题。 打开keychain钥匙串访问 打开菜单，选择「证书助理」-&gt;「创建证书」 输入一个名字，比如dlv-cert，然后将identify type（身份类型）设置为self signed root（自签名根证书），将certificate type（证书类型）设置为code signing（代码签名），然后选择let me override defaults（让我覆盖这些默认值） 点击continue，此处你可以调整一下证书的过期时间，如将默认的365改为3650 继续点击continue直到你看到specify a location for the certificate（指定该证书用于的位置），选择system如果不能就选择login，然后导出到system的keychain中 在keychains里选择system，然后就可以找到新建的证书，右键点击证书，选择get info（显示简介），打开trust选项，然后将code signing设置为always trust （Yosemite）在keychain里选择keys，然后找到证书，右键点击，选择get info，然后选择access control标签，选择allow all applications to access this item，然后保存设置 退出keychain，杀死taskgated进程重启该服务，或者直接重启电脑 重新编译出带有代码签名的dlv执行程序。打开Termina进入$GOPATH/src/github.com/derekparker/delve，如果你的Go版本为1.5你必须先执行GO15VENDOREXPERIMENT=1命令，接下来输入CERT=dlv-cert make install命令，这样就可以重新编译出一个带有代码签名的dlv。 参考文档 https://github.com/Microsoft/vscode-go https://github.com/derekparker/delve/blob/master/Documentation/installation/osx/install.md","tags":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/tags/IT/"}]},{"title":"原来isKindOfClass并非那么可靠","date":"2016-01-21T03:15:29.000Z","path":"2016/01/21/原来isKindOfClass并非那么可靠/","text":"从正式开发iOS的那天起，我便了解-isKindOfClass:可以用来确定一个对象是否是一个类的成员，也可以用来确定一个对象是否是派生自该类的类的成员。可实际上它并不值得被信任。 下面以NSURLSessionDataTask这个类来阐述为什么isKindOfClass并不可靠。 我们可以打印出NSURLSessionDataTask的继承树，代码如下： 12345NSURLSessionDataTask *task = [[NSURLSession sharedSession] dataTaskWithURL:[NSURL URLWithString:@\"http://blog.leonluo.com\"]];NSLog(@\"%@\", [task class]);NSLog(@\"%@\", [task superclass]);NSLog(@\"%@\", [[task superclass] superclass]);NSLog(@\"%@\", [[[task superclass] superclass] superclass]); 在iOS8以上的结果是： __NSCFLocalDataTask __NSCFLocalSessionTask NSURLSessionTask NSObject 在iOS7上的结果是： __NSCFLocalDataTask __NSCFLocalSessionTask __NSCFURLSessionTask NSObject 如果我们去问，我们建立的这些data task到底是不是NSURLSessionDataTask，调用[task isKindOfClass:[NSURLSessionDataTask class]]，得到的结果还是YES，可事实上它来自__NSCFLocalDataTask。 其实-isKindOfClass:是可以override掉的，所以，即使__NSCFLocalDataTask根本就不是NSURLSessionDataTask，但我们可以把__NSCFLocalDataTask的-isKindOfClass:写成这样： - (BOOL)isKindOfClass:(Class)aClass { if (aClass == NSClassFromString(@&quot;NSURLSessionDataTask&quot;)) { return YES; } if (aClass == NSClassFromString(@&quot;NSURLSessionTask&quot;)) { return YES; } return [super isKindOfClass:aClass]; } 无论是iOS8还是iOS7我们建立的data task，都不是直接产生NSURLSessionDataTask，而是产生__NSCFLocalDataTask这样的private class。 -isKindOfClass:并不那么可靠。","tags":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/tags/IT/"}]},{"title":"无题","date":"2015-12-23T09:49:13.000Z","path":"2015/12/23/无题/","text":"rm -rf ~/life/2015/memory/bad/./init_new_yeartouch ~/life/2016/wishes/firstecho “Everything will be okay.”&gt;~/life/2016/wishes/first","tags":[]}]